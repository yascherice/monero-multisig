use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::path::{Path, PathBuf};

use crate::config::RpcClient;

/// Parameters for creating a new multisig wallet.
#[derive(Debug, Clone)]
pub struct MultisigParams {
    /// Number of required signers (M in M-of-N).
    pub threshold: u32,
    /// Total number of participants (N in M-of-N).
    pub total: u32,
    /// Human-readable label for this wallet.
    pub label: String,
}

impl MultisigParams {
    pub fn new(threshold: u32, total: u32, label: String) -> Result<Self> {
        anyhow::ensure!(threshold >= 1, "threshold must be at least 1");
        anyhow::ensure!(
            threshold <= total,
            "threshold ({threshold}) cannot exceed total participants ({total})"
        );
        anyhow::ensure!(total >= 2, "multisig requires at least 2 participants");
        Ok(Self {
            threshold,
            total,
            label,
        })
    }
}

/// Represents a single participant's multisig info string produced during key
/// exchange. These opaque blobs are generated by the Monero wallet RPC and
/// must be shared between all participants.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MultisigInfo {
    pub participant_index: u32,
    pub info_string: String,
}

/// Tracks the state of a multisig wallet through its setup lifecycle.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum WalletState {
    /// Initial state — wallet created, awaiting first key exchange round.
    Created {
        wallet_path: PathBuf,
        params: SerializableParams,
    },
    /// One or more key exchange rounds completed; more rounds may be needed.
    KeyExchangeInProgress {
        wallet_path: PathBuf,
        params: SerializableParams,
        rounds_completed: u32,
        rounds_required: u32,
    },
    /// All key exchange rounds finished — wallet is ready for use.
    Ready {
        wallet_path: PathBuf,
        address: String,
        params: SerializableParams,
    },
}

/// Serializable copy of [`MultisigParams`] for persisting wallet state.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SerializableParams {
    pub threshold: u32,
    pub total: u32,
    pub label: String,
}

impl From<&MultisigParams> for SerializableParams {
    fn from(p: &MultisigParams) -> Self {
        Self {
            threshold: p.threshold,
            total: p.total,
            label: p.label.clone(),
        }
    }
}

// ── Wallet RPC response types ───────────────────────────────────────────────

#[derive(Debug, Deserialize)]
struct PrepareMultisigResponse {
    multisig_info: String,
}

#[derive(Debug, Deserialize)]
struct MakeMultisigResponse {
    address: String,
    #[allow(dead_code)]
    multisig_info: String,
}

#[derive(Debug, Deserialize)]
struct ExchangeMultisigKeysResponse {
    address: String,
    multisig_info: String,
}

#[derive(Debug, Deserialize)]
struct FinalizeMultisigResponse {
    address: String,
}

// ── Public API ──────────────────────────────────────────────────────────────

/// Prepare a new wallet for multisig by calling `prepare_multisig`.
///
/// Returns the participant's multisig info string that must be shared with all
/// other participants in the first key exchange round.
pub async fn prepare_multisig(rpc: &RpcClient) -> Result<String> {
    let resp: PrepareMultisigResponse = rpc
        .request("prepare_multisig", &serde_json::json!({}))
        .await
        .context("prepare_multisig RPC call failed")?;

    Ok(resp.multisig_info)
}

/// Perform a round of multisig key exchange with the provided info strings
/// from other participants.
///
/// For an M-of-N wallet:
/// - 2-of-N requires a single `make_multisig` call.
/// - M-of-N where M > 2 requires (M - 1) rounds of `exchange_multisig_keys`,
///   followed by a final `finalize_multisig`.
pub async fn exchange_keys(
    rpc: &RpcClient,
    peer_info: &[String],
    threshold: u32,
    password: &str,
) -> Result<KeyExchangeResult> {
    if threshold == 2 {
        let resp: MakeMultisigResponse = rpc
            .request(
                "make_multisig",
                &serde_json::json!({
                    "multisig_info": peer_info,
                    "threshold": threshold,
                    "password": password,
                }),
            )
            .await
            .context("make_multisig RPC call failed")?;

        Ok(KeyExchangeResult::Complete {
            address: resp.address,
        })
    } else {
        let resp: ExchangeMultisigKeysResponse = rpc
            .request(
                "exchange_multisig_keys",
                &serde_json::json!({
                    "multisig_info": peer_info,
                    "password": password,
                }),
            )
            .await
            .context("exchange_multisig_keys RPC call failed")?;

        if resp.address.is_empty() {
            Ok(KeyExchangeResult::Partial {
                next_info: resp.multisig_info,
            })
        } else {
            Ok(KeyExchangeResult::Complete {
                address: resp.address,
            })
        }
    }
}

/// Finalize the multisig wallet after all intermediate exchange rounds.
pub async fn finalize_multisig(
    rpc: &RpcClient,
    peer_info: &[String],
    password: &str,
) -> Result<String> {
    let resp: FinalizeMultisigResponse = rpc
        .request(
            "finalize_multisig",
            &serde_json::json!({
                "multisig_info": peer_info,
                "password": password,
            }),
        )
        .await
        .context("finalize_multisig RPC call failed")?;

    Ok(resp.address)
}

/// The outcome of a single key exchange round.
#[derive(Debug)]
pub enum KeyExchangeResult {
    /// More rounds are needed; share `next_info` with peers.
    Partial { next_info: String },
    /// Key exchange is complete; the wallet address is ready.
    Complete { address: String },
}

/// Persist wallet state to a JSON file inside `data_dir`.
pub fn save_wallet_state(data_dir: &Path, state: &WalletState) -> Result<()> {
    std::fs::create_dir_all(data_dir)?;
    let path = data_dir.join("wallet_state.json");
    let json = serde_json::to_string_pretty(state)?;
    std::fs::write(&path, json)?;
    tracing::info!("Wallet state saved to {}", path.display());
    Ok(())
}

/// Load wallet state from a previously saved JSON file.
pub fn load_wallet_state(data_dir: &Path) -> Result<WalletState> {
    let path = data_dir.join("wallet_state.json");
    let contents =
        std::fs::read_to_string(&path).context("no wallet state found — run create-wallet first")?;
    let state: WalletState = serde_json::from_str(&contents)?;
    Ok(state)
}

/// Check whether a wallet state file exists in the data directory.
pub fn wallet_exists(data_dir: &Path) -> bool {
    data_dir.join("wallet_state.json").exists()
}

/// Delete wallet state and associated data.
pub fn delete_wallet(data_dir: &Path) -> Result<()> {
    let path = data_dir.join("wallet_state.json");
    if path.exists() {
        std::fs::remove_file(&path)?;
        tracing::info!("Wallet state removed from {}", path.display());
    }
    Ok(())
}
